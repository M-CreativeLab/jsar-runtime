use std::env;
use std::fs;
use std::io::Error;
use std::path::Path;
use std::path::PathBuf;

extern crate cbindgen;

fn main() {
  // Tell cargo to re-run this script if the env FORCE_REBUILD is set.
  println!("cargo:rerun-if-env-changed=FORCE_REBUILD");
  // Tell cargo to re-run this script if the Rust files have changed.
  println!("cargo:rerun-if-changed=lib.rs");
  println!("cargo:rerun-if-changed=css_parser.rs");
  println!("cargo:rerun-if-changed=layout.rs");
  println!("cargo:rerun-if-changed=typescript_transpiler.rs");
  println!("cargo:rerun-if-changed=glsl_transpiler/");
  // Tell cargo to re-run when the bindings changed.
  println!("cargo:rerun-if-changed=bindings.base.h");
  println!("cargo:rerun-if-changed=bindings.hpp");

  // Generate C bindings
  generate_cbinding();

  // Install headers
  install_header("bindings.base.h");
  install_header("bindings.autogen.h");
  install_header("bindings.hpp");
}

fn generate_cbinding() {
  let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
  cbindgen::Builder::new()
    .with_tab_width(2)
    .with_namespace("holocron")
    .with_language(cbindgen::Language::Cxx)
    .with_autogen_warning("/* Autogenerated file. Do not edit. */")
    .with_pragma_once(true)
    .with_sys_include("assert.h")
    .with_include("./bindings.base.h")
    .with_item_prefix("_")
    .with_crate(crate_dir)
    .generate()
    .expect("Unable to generate bindings")
    .write_to_file("bindings.autogen.h");
}

fn install_header(file_name: &str) {
  let current_dir = env::current_dir().unwrap();
  let source_path = current_dir.join(file_name);
  if !source_path.exists() {
    panic!("Error: File '{}' not found.", file_name);
  }
  let destination_dir = PathBuf::from(&current_dir).join("../../build/output/headers/crates/");
  if !destination_dir.exists() {
    std::fs::create_dir_all(&destination_dir).expect("Failed to create the destination directory.");
  }

  let destination_path = destination_dir.join(file_name);
  match copy_file(&source_path, &destination_path) {
    Ok(_) => println!(
      "File '{}' copied to '{}'",
      file_name,
      destination_path.to_str().unwrap()
    ),
    Err(e) => panic!("Error copying file: {:?}", e),
  }
}

fn copy_file(source: &Path, destination: &Path) -> Result<(), Error> {
  let content = fs::read_to_string(source)?;
  fs::write(destination, content)?;
  Ok(())
}
